/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "ndmp.h"

bool_t
xdr_ndmp_header_message_type (XDR *xdrs, ndmp_header_message_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_pval (XDR *xdrs, ndmp_pval *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->value, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_u_quad (XDR *xdrs, ndmp_u_quad *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->high))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->low))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_error (XDR *xdrs, ndmp_error *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_message (XDR *xdrs, ndmp_message *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_connection_status_reason (XDR *xdrs, ndmp_connection_status_reason *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_auth_type (XDR *xdrs, ndmp_auth_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_addr_type (XDR *xdrs, ndmp_addr_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_log_type (XDR *xdrs, ndmp_log_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_has_associated_message (XDR *xdrs, ndmp_has_associated_message *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_halt_reason (XDR *xdrs, ndmp_data_halt_reason *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_state (XDR *xdrs, ndmp_data_state *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_operation (XDR *xdrs, ndmp_data_operation *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_auth_attr (XDR *xdrs, ndmp_auth_attr *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_auth_type (xdrs, &objp->auth_type))
		 return FALSE;
	switch (objp->auth_type) {
	case NDMP_AUTH_NONE:
		break;
	case NDMP_AUTH_TEXT:
		break;
	case NDMP_AUTH_MD5:
		 if (!xdr_opaque (xdrs, objp->ndmp_auth_attr_u.challenge, 64))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_ndmp_header (XDR *xdrs, ndmp_header *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->sequence))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->time_stamp))
		 return FALSE;
	 if (!xdr_ndmp_header_message_type (xdrs, &objp->message_type))
		 return FALSE;
	 if (!xdr_ndmp_message (xdrs, &objp->message_code))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->reply_sequence))
		 return FALSE;
	 if (!xdr_ndmp_error (xdrs, &objp->error_code))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_notify_connection_status_post (XDR *xdrs, ndmp_notify_connection_status_post *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_connection_status_reason (xdrs, &objp->reason))
		 return FALSE;
	 if (!xdr_u_short (xdrs, &objp->protocol_version))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->text_reason, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_connect_open_request (XDR *xdrs, ndmp_connect_open_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_short (xdrs, &objp->protocol_version))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_connect_open_reply (XDR *xdrs, ndmp_connect_open_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_config_get_server_info_reply (XDR *xdrs, ndmp_config_get_server_info_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->vendor_name, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->product_name, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->revision_number, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->auth_type.auth_type_val, (u_int *) &objp->auth_type.auth_type_len, ~0,
		sizeof (ndmp_auth_type), (xdrproc_t) xdr_ndmp_auth_type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_config_get_auth_attr_request (XDR *xdrs, ndmp_config_get_auth_attr_request *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_auth_type (xdrs, &objp->auth_type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_config_get_auth_attr_reply (XDR *xdrs, ndmp_config_get_auth_attr_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_ndmp_auth_attr (xdrs, &objp->server_attr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_auth_md5 (XDR *xdrs, ndmp_auth_md5 *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_string (xdrs, &objp->auth_id, ~0))
		 return FALSE;
	 if (!xdr_opaque (xdrs, objp->auth_digest, 16))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_auth_text (XDR *xdrs, ndmp_auth_text *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->auth_id, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->auth_password, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_auth_data (XDR *xdrs, ndmp_auth_data *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_auth_type (xdrs, &objp->auth_type))
		 return FALSE;
	switch (objp->auth_type) {
	case NDMP_AUTH_NONE:
		break;
	case NDMP_AUTH_TEXT:
		 if (!xdr_ndmp_auth_text (xdrs, &objp->ndmp_auth_data_u.auth_text))
			 return FALSE;
		break;
	case NDMP_AUTH_MD5:
		 if (!xdr_ndmp_auth_md5 (xdrs, &objp->ndmp_auth_data_u.auth_md5))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_ndmp_connect_client_auth_request (XDR *xdrs, ndmp_connect_client_auth_request *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_auth_data (xdrs, &objp->auth_data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_connect_client_auth_reply (XDR *xdrs, ndmp_connect_client_auth_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_butype_info (XDR *xdrs, ndmp_butype_info *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->butype_name, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->default_env.default_env_val, (u_int *) &objp->default_env.default_env_len, ~0,
		sizeof (ndmp_pval), (xdrproc_t) xdr_ndmp_pval))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->attrs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_config_get_butype_attr_reply (XDR *xdrs, ndmp_config_get_butype_attr_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->butype_info.butype_info_val, (u_int *) &objp->butype_info.butype_info_len, ~0,
		sizeof (ndmp_butype_info), (xdrproc_t) xdr_ndmp_butype_info))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_config_get_connection_type_reply (XDR *xdrs, ndmp_config_get_connection_type_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->addr_types.addr_types_val, (u_int *) &objp->addr_types.addr_types_len, ~0,
		sizeof (ndmp_addr_type), (xdrproc_t) xdr_ndmp_addr_type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_fs_info (XDR *xdrs, ndmp_fs_info *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->unsupported))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->fs_type, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->fs_logical_device, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->fs_physical_device, ~0))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->total_size))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->used_size))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->avail_size))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->total_inodes))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->used_inodes))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->fs_env.fs_env_val, (u_int *) &objp->fs_env.fs_env_len, ~0,
		sizeof (ndmp_pval), (xdrproc_t) xdr_ndmp_pval))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->fs_status, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_config_get_fs_info_reply (XDR *xdrs, ndmp_config_get_fs_info_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->fs_info.fs_info_val, (u_int *) &objp->fs_info.fs_info_len, ~0,
		sizeof (ndmp_fs_info), (xdrproc_t) xdr_ndmp_fs_info))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_ipc_addr (XDR *xdrs, ndmp_ipc_addr *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->comm_data.comm_data_val, (u_int *) &objp->comm_data.comm_data_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_tcp_addr (XDR *xdrs, ndmp_tcp_addr *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->ip_addr))
		 return FALSE;
	 if (!xdr_u_short (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->addr_env.addr_env_val, (u_int *) &objp->addr_env.addr_env_len, ~0,
		sizeof (ndmp_pval), (xdrproc_t) xdr_ndmp_pval))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_addr (XDR *xdrs, ndmp_addr *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_addr_type (xdrs, &objp->addr_type))
		 return FALSE;
	switch (objp->addr_type) {
	case NDMP_ADDR_LOCAL:
		break;
	case NDMP_ADDR_TCP:
		 if (!xdr_array (xdrs, (char **)&objp->ndmp_addr_u.tcp_addr.tcp_addr_val, (u_int *) &objp->ndmp_addr_u.tcp_addr.tcp_addr_len, ~0,
			sizeof (ndmp_tcp_addr), (xdrproc_t) xdr_ndmp_tcp_addr))
			 return FALSE;
		break;
	case NDMP_ADDR_IPC:
		 if (!xdr_ndmp_ipc_addr (xdrs, &objp->ndmp_addr_u.ipc_addr))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_ndmp_data_connect_request (XDR *xdrs, ndmp_data_connect_request *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_addr (xdrs, &objp->addr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_connect_reply (XDR *xdrs, ndmp_data_connect_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_start_backup_request (XDR *xdrs, ndmp_data_start_backup_request *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->butype_name, ~0))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->env.env_val, (u_int *) &objp->env.env_len, ~0,
		sizeof (ndmp_pval), (xdrproc_t) xdr_ndmp_pval))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_start_backup_reply (XDR *xdrs, ndmp_data_start_backup_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_log_message_post (XDR *xdrs, ndmp_log_message_post *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_log_type (xdrs, &objp->log_type))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->message_id))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->entry, ~0))
		 return FALSE;
	 if (!xdr_ndmp_has_associated_message (xdrs, &objp->associated_message_valid))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->associated_message_sequence))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_notify_data_halted_post (XDR *xdrs, ndmp_notify_data_halted_post *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_data_halt_reason (xdrs, &objp->reason))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_get_state_reply (XDR *xdrs, ndmp_data_get_state_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->unsupported))
		 return FALSE;
	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_ndmp_data_operation (xdrs, &objp->operation))
		 return FALSE;
	 if (!xdr_ndmp_data_state (xdrs, &objp->state))
		 return FALSE;
	 if (!xdr_ndmp_data_halt_reason (xdrs, &objp->halt_reason))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->bytes_processed))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->est_bytes_remain))
		 return FALSE;
	 if (!xdr_u_long (xdrs, &objp->est_time_remain))
		 return FALSE;
	 if (!xdr_ndmp_addr (xdrs, &objp->data_connection_addr))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->read_offset))
		 return FALSE;
	 if (!xdr_ndmp_u_quad (xdrs, &objp->read_length))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_get_env_reply (XDR *xdrs, ndmp_data_get_env_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->env.env_val, (u_int *) &objp->env.env_len, ~0,
		sizeof (ndmp_pval), (xdrproc_t) xdr_ndmp_pval))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_abort_reply (XDR *xdrs, ndmp_data_abort_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ndmp_data_stop_reply (XDR *xdrs, ndmp_data_stop_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_ndmp_error (xdrs, &objp->error))
		 return FALSE;
	return TRUE;
}
